# JavaScript Event Loop & Concurrency  
## Topic 3: Microtask Queue (Promises vs. Callbacks)

In addition to the **Callback Queue**, JavaScript also uses a **Microtask Queue** (or Microtask Job Queue) to manage certain asynchronous tasks like **Promises** and **MutationObservers**.

---

## ðŸ”¹ What is the Microtask Queue?

- A special queue with **higher priority** than the Callback Queue.
- Tasks in the Microtask Queue are executed **after the current execution stack**, but **before** any callback/event from the Callback Queue.

---

## ðŸ”§ Microtask vs Callback Example

```javascript
console.log("Start");

setTimeout(() => {
  console.log("â° Timeout Callback");
}, 0);

Promise.resolve().then(() => {
  console.log("âœ… Promise Resolved");
});

console.log("End");
Expected Output:

sql
Copy
Edit
Start
End
âœ… Promise Resolved
â° Timeout Callback
ðŸ“Š Execution Flow
vbnet
Copy
Edit
1. Call Stack runs "Start" â†’ logs
2. Call Stack runs "End" â†’ logs
3. Promise's `.then()` goes to Microtask Queue
4. setTimeout callback goes to Callback Queue
5. Call Stack is empty â†’ Event Loop checks Microtask Queue first
6. Runs Promise callback â†’ logs "âœ… Promise Resolved"
7. Then runs Timeout callback â†’ logs "â° Timeout Callback"
ðŸ” Microtask Sources
Promise.then(), Promise.catch(), Promise.finally()

queueMicrotask()

MutationObserver

ðŸ”§ Example with queueMicrotask()
javascript
Copy
Edit
queueMicrotask(() => {
  console.log("ðŸ§µ Microtask running");
});

console.log("Main thread done");
Output:

arduino
Copy
Edit
Main thread done  
ðŸ§µ Microtask running
âœ… Summary
Microtasks run before Callback Queue tasks.

Promises are scheduled in the Microtask Queue.

Great for fine-grained async behavior that runs immediately after synchronous code.

Event Loop checks the Microtask Queue after every stack operation.

